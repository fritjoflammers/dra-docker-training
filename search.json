[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "dra course - Docker Fundamentals",
    "section": "",
    "text": "1 Introduction",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "index.html#contact",
    "href": "index.html#contact",
    "title": "dra course - Docker Fundamentals",
    "section": "1.1 Contact",
    "text": "1.1 Contact\nIn case of questions, or suggestions, please open a GitHub issue. Thanks!",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "working-with-the-shell/01-shell_basics.html",
    "href": "working-with-the-shell/01-shell_basics.html",
    "title": "2¬† Shell basics",
    "section": "",
    "text": "2.1 What is the Shell?\nThis session consists of some slides that are available here.",
    "crumbs": [
      "Working with the Shell",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Shell basics</span>"
    ]
  },
  {
    "objectID": "working-with-the-shell/01-shell_basics.html#navigating-the-file-system",
    "href": "working-with-the-shell/01-shell_basics.html#navigating-the-file-system",
    "title": "2¬† Shell basics",
    "section": "2.2 Navigating the file system",
    "text": "2.2 Navigating the file system\nFollow along with the instructor as they demonstrate how to navigate the file system using the shell.\n\n2.2.1 pwd\nThe pwd command is used to print the current working directory.\npwd\n\n\n2.2.2 ls\nThe ls command is used to list the contents of a directory.\nls\nYou can also use the -l option to display more information about the files.\nls -l\nThe output of ls -l looks like this:\ndrwxr-xr-x 2 user user 4096 Mar  1 10:00 my-directory\n-rw-r--r-- 1 user user  123 Mar  1 10:00 my-file.txt\nThe columns in the output are as follows:\n\ndrwxr-xr-x indicates the type of the file or directory and the permissions.\n1number of links to the file or directory.\nuser owner of the file or directory.\nuser group of the file or directory.\n4096 size of the file or directory (in bytes)\nMar 1 10:00 date and time the file or directory was last modified.\nmy-directory name of the file or directory.\n\n\n\n\n\n\n\nHidden files\n\n\n\nFiles that start with a . are hidden files. You can display them using the -a option.\nls -a",
    "crumbs": [
      "Working with the Shell",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Shell basics</span>"
    ]
  },
  {
    "objectID": "working-with-the-shell/01-shell_basics.html#mkdir",
    "href": "working-with-the-shell/01-shell_basics.html#mkdir",
    "title": "2¬† Shell basics",
    "section": "2.3 mkdir",
    "text": "2.3 mkdir\nThe mkdir command is used to create directories.\nmkdir my-new-directory\nYou can also create multiple directories at once.\nmkdir my-new-directory my-other-directory\n\n\n\n\n\n\nCreating nested directories\n\n\n\nYou can create nested directories by using the -p option. The -p option will create all parent directories if they do not exist.\nmkdir -p my-new-directory/nested-directory",
    "crumbs": [
      "Working with the Shell",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Shell basics</span>"
    ]
  },
  {
    "objectID": "working-with-the-shell/01-shell_basics.html#cd",
    "href": "working-with-the-shell/01-shell_basics.html#cd",
    "title": "2¬† Shell basics",
    "section": "2.4 cd",
    "text": "2.4 cd\nThe cd command is used to change directories.\ncd my-directory\nYou can also use cd with a path to navigate to a directory that is not in the current working directory.\ncd /path/to/my-directory\n\n\n\n\n\n\nUnderstanding ‚Äú..‚Äù and ‚Äú.‚Äù\n\n\n\n\n.. refers to the parent directory\n. refers to the current directory\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\nCreate the following (or similar) directory structure.\nmy-research-project/\n    data/\n        raw/\n        clean/\n    analysis/\n    results/\n    doc/",
    "crumbs": [
      "Working with the Shell",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Shell basics</span>"
    ]
  },
  {
    "objectID": "working-with-the-shell/01-shell_basics.html#understanding-paths",
    "href": "working-with-the-shell/01-shell_basics.html#understanding-paths",
    "title": "2¬† Shell basics",
    "section": "2.5 Understanding paths",
    "text": "2.5 Understanding paths\nPaths are used to specify the location of a file or directory in the file system.\nThey can be either absolute or relative. Absolute paths can be seen as the full address of a file or directory, whereas relative paths are relative to the current working directory. They can be seen as asking a local in the neighborhood for directions.\nIn Linux absolute paths look like this: /home/username/my-research-project/data/raw\nUnder MacOS they look like this: /Users/username/my-research-project/data/raw\nAnd in Windows: C:\\Users\\username\\my-research-project\\data\\raw\n\n\n\n\n\n\nThe ‚ÄúHome‚Äù directory\n\n\n\nThe home directory is the directory where you land when you open a terminal. It is usually /home/username in Linux, /Users/username in MacOS and C:\\Users\\username in Windows.\nTo navigate to the home directory you can use the cd command without any arguments.",
    "crumbs": [
      "Working with the Shell",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Shell basics</span>"
    ]
  },
  {
    "objectID": "working-with-the-shell/01-shell_basics.html#writing-and-viewing-files",
    "href": "working-with-the-shell/01-shell_basics.html#writing-and-viewing-files",
    "title": "2¬† Shell basics",
    "section": "2.6 Writing and viewing files",
    "text": "2.6 Writing and viewing files\n\n2.6.1 echo\nThe echo command is used to print text to the terminal. When writing scripts, it is often used to print messages to the user.\necho \"Hello, world!\"\n\n\n2.6.2 nano\nnano is a simple text editor that is often used in the shell.\nTo open a file in nano:\nnano my-file.txt\nYou can also create a new file by providing a name that does not exist.\nTo save and exit nano: - Press Ctrl + O to save - Press Enter to confirm the file name\nWhen you start nano without providing a file name, you can specify the filename when you save the file (Ctrl + O).\n\nPress Ctrl + X to exit without saving.\n\n\n\n\n\n\n\nUsing nano\n\n\n\nnano‚Äôs commands are displayed at the bottom of the screen. They can be invoked by pressing Ctrl and the corresponding letter.\n\n\n\n\n2.6.3 less\nless is a program that allows you to view the contents of a file.\nless my-file.txt\nNavigate through the file using the arrow keys, or Page Up and Page Down.\nTo exit less, press q.\n\n\n2.6.4 &gt; and &gt;&gt;\nThe &gt; and &gt;&gt; operators are used to redirect the output of a command to a file.\n\n&gt; will overwrite the file if it already exists\n&gt;&gt; will append the output to the file\n\necho \"Hello, world!\" &gt; my-file.txt\necho \"Hello, again!\" &gt;&gt; my-file.txt",
    "crumbs": [
      "Working with the Shell",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Shell basics</span>"
    ]
  },
  {
    "objectID": "working-with-the-shell/01-shell_basics.html#general-syntax-of-a-shell-command",
    "href": "working-with-the-shell/01-shell_basics.html#general-syntax-of-a-shell-command",
    "title": "2¬† Shell basics",
    "section": "2.7 General syntax of a shell command",
    "text": "2.7 General syntax of a shell command\ncommand -option argument\n\ncommand is the name of the command\n-option is an option that modifies the behavior of the command\nargument is the input to the command\n\n\n\n\n\n\n\nCommand options\n\n\n\nOptions are usually preceded by a - or --. They can be combined, e.g.¬†-a -b -c can be written as -abc.\n\n\n\n\n\n\n\n\nExercise\n\n\n\nUse the commands you have learned to create a README file in your research directory. Try various commands to create the file, modify it, and view its contents.",
    "crumbs": [
      "Working with the Shell",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Shell basics</span>"
    ]
  },
  {
    "objectID": "working-with-the-shell/01-shell_basics.html#moving-and-removing-files",
    "href": "working-with-the-shell/01-shell_basics.html#moving-and-removing-files",
    "title": "2¬† Shell basics",
    "section": "2.8 Moving and removing files",
    "text": "2.8 Moving and removing files\n\n2.8.1 mv\nThe mv command is used to move files and directories.\n\nmv my-file.txt my-research-project/doc/\nIt can also be used to rename files.\nmv my-file.txt my-new-file.txt\n\n\n2.8.2 cp\nThe cp command is used to copy files and directories.\ncp my-file.txt my-file-copy.txt\nTo copy a directory, you need to use the -r option.\ncp -r my-research-project my-research-project-copy\n\n\n2.8.3 rm\n\n\n\n\n\n\nBe careful with rm\n\n\n\nThe rm command will permanently delete files and directories. There is no way to recover them.\nWhen you are unsure about using rm, you can use the -i option to prompt you before deleting each file.\n\n\nThe rm command is used to remove files and directories.\nrm my-file.txt\nTo remove a directory, you need to use the -r option.\nrm -r test/",
    "crumbs": [
      "Working with the Shell",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Shell basics</span>"
    ]
  },
  {
    "objectID": "working-with-the-shell/01-shell_basics.html#getting-help",
    "href": "working-with-the-shell/01-shell_basics.html#getting-help",
    "title": "2¬† Shell basics",
    "section": "2.9 Getting Help",
    "text": "2.9 Getting Help\nThe man command is used to display the manual page of a command.\nOften, you can also use the --help option to get a brief overview of the command and its options.\nFor example\ncp --help",
    "crumbs": [
      "Working with the Shell",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Shell basics</span>"
    ]
  },
  {
    "objectID": "working-with-the-shell/01-shell_basics.html#summary",
    "href": "working-with-the-shell/01-shell_basics.html#summary",
    "title": "2¬† Shell basics",
    "section": "2.10 Summary",
    "text": "2.10 Summary\n\nThe shell is a powerful tool for interacting with the file system and running programs.\nYou can navigate the file system using commands like cd, ls, and pwd.\nYou can create, move, and remove files using commands like touch, mv, cp, and rm.\nYou can view the contents of files using commands like cat, less, and nano.\nYou can redirect the output of commands to files using &gt; and &gt;&gt;.\nYou can get help on commands using the man command or the --help option.",
    "crumbs": [
      "Working with the Shell",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Shell basics</span>"
    ]
  },
  {
    "objectID": "working-with-the-shell/01-shell_basics.html#further-reading",
    "href": "working-with-the-shell/01-shell_basics.html#further-reading",
    "title": "2¬† Shell basics",
    "section": "2.11 Further reading",
    "text": "2.11 Further reading\n\nUbuntu Command Line Tutorial",
    "crumbs": [
      "Working with the Shell",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Shell basics</span>"
    ]
  },
  {
    "objectID": "working-with-the-shell/99-reference.html",
    "href": "working-with-the-shell/99-reference.html",
    "title": "3¬† Command reference",
    "section": "",
    "text": "pwd: Print working directory\nmkdir: Make directory\nls: List directory contents\ncd: Change directory\necho: Display a line of text\nless: View file contents page by page\nnano: Text editor\n&gt;: Redirect output (overwrite)\n&gt;&gt;: Redirect output (append)\ncp: Copy files or directories\nmv: Move (rename) files or directories\nrm: Remove files or directories",
    "crumbs": [
      "Working with the Shell",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Command reference</span>"
    ]
  },
  {
    "objectID": "learning-git/02-git_collaboration.html",
    "href": "learning-git/02-git_collaboration.html",
    "title": "4¬† Collaborating with Git",
    "section": "",
    "text": "4.1 The default git workflow\nYou have learned about the standard git workflow in the previous chapter, where you work on your local repository, commit changes and push them to the remote repository.\nThis is the default git workflow for a single developer.\nHowever, when you work in a team, you need to collaborate with other developers. In this chapter, you will learn how to collaborate with other developers using git.",
    "crumbs": [
      "Version Control with Git",
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Collaborating with Git</span>"
    ]
  },
  {
    "objectID": "learning-git/02-git_collaboration.html#the-default-git-workflow",
    "href": "learning-git/02-git_collaboration.html#the-default-git-workflow",
    "title": "4¬† Collaborating with Git",
    "section": "",
    "text": "Single developer Git workflow. Alice develops a repository and is the only person, commiting and pushing her changes to a remote repository in the cloud.\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nRemember that git is decentralized.\nThis means, each developer has a full copy of the repository on their local machine",
    "crumbs": [
      "Version Control with Git",
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Collaborating with Git</span>"
    ]
  },
  {
    "objectID": "learning-git/02-git_collaboration.html#the-collaborative-workflow",
    "href": "learning-git/02-git_collaboration.html#the-collaborative-workflow",
    "title": "4¬† Collaborating with Git",
    "section": "4.2 The collaborative workflow",
    "text": "4.2 The collaborative workflow\nLet‚Äôs look what happens when you work on a project as a team.\nYour team member clone the remote repository to their local machine. They work on their local repository and push their changes to the remote repository.\nNow what will happen, when you have done work in the same time and you both push your changes to the remote repository?\n\n\n\nCollaborative git workflow. Divergent changes push by Bob to the remote repository, cause Alice‚Äôs push to be rejected. To add her changes too, she has to pull changes from the remote repository, merge them and then push her changes.\n\n\nThe first thing happening that you will get an error message when you try to push your changes to the remote repository. This is because the remote repository has been updated by your team member.\nWhen you work on the same file, you may have conflicts. You need to resolve these conflicts before you can push your changes to the remote repository.",
    "crumbs": [
      "Version Control with Git",
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Collaborating with Git</span>"
    ]
  },
  {
    "objectID": "learning-git/02-git_collaboration.html#conflicts",
    "href": "learning-git/02-git_collaboration.html#conflicts",
    "title": "4¬† Collaborating with Git",
    "section": "4.3 Conflicts",
    "text": "4.3 Conflicts\nA conflict occurs when two developers change the same file and the same line in the file.\nWhen you pull changes from the remote repository, git will try to merge the changes. If git can‚Äôt merge the changes automatically, you will get a conflict.\nGit will notify about the conflict with a message similar to this:\nAuto-merging file.txt\nCONFLICT (content): Merge conflict in file.txt\nAutomatic merge failed; fix conflicts and then commit the result.\nWhen you open the file, you will see the conflict markers:\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD\nThis is the content of the file after the changes from the remote repository\n=======\nThis is the content of the file after the changes from your local repository\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1234567890abcdef1234567890abcdef12345678\nThe conflict markers are:\n\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD - The content of the file after the changes from the remote repository\n======= - The separator\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1234567890abcdef1234567890abcdef12345678 - The content of the file after the changes from your local repository\n\nTo resolve the conflict, edit the file, keeping the changes you want to keep and removing the conflict markers.\nAfter you have resolved the conflict, you need to add the file to the staging area and commit the changes.",
    "crumbs": [
      "Version Control with Git",
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Collaborating with Git</span>"
    ]
  },
  {
    "objectID": "learning-git/02-git_collaboration.html#branches",
    "href": "learning-git/02-git_collaboration.html#branches",
    "title": "4¬† Collaborating with Git",
    "section": "4.4 Branches",
    "text": "4.4 Branches\nA way to avoid conflicts is to work on different branches. The default branch in git is called main.\nPreviously, it was often called master, however this term is being phased out because of its negative connotations.\nYou can create a new branch with the git branch command.\nWhen working on a branch, you can push your changes to the remote repository without conflicts. When you are done with your work, you can merge the branch back to the main branch.",
    "crumbs": [
      "Version Control with Git",
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Collaborating with Git</span>"
    ]
  },
  {
    "objectID": "learning-git/03-gitlab_collaboration.html",
    "href": "learning-git/03-gitlab_collaboration.html",
    "title": "5¬† GitLab for collaboration",
    "section": "",
    "text": "GitLab is a web-based Git repository manager with wiki and issue tracking features.\nIt is a software that allows to host and manage remote repositories.\nIn addition, it provides a lot of features to manage the development process and facilitate collaboration between developers.",
    "crumbs": [
      "Version Control with Git",
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>GitLab for collaboration</span>"
    ]
  },
  {
    "objectID": "01-introduction.html",
    "href": "01-introduction.html",
    "title": "6¬† Stable Computing Environments",
    "section": "",
    "text": "6.1 Opening demo\nCreate a Python script called plot.py with the following content:\nTry running the script by executing\nDoes it work?\nLikely, you will get an error message that matplotlib is not installed. Possibly also Python is not installed on your system, showing error message like: python: command not found.\nWhen you have Docker installed, you can run the script in a Docker container with the following command:",
    "crumbs": [
      "Docker Fundamentals",
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Stable Computing Environments</span>"
    ]
  },
  {
    "objectID": "01-introduction.html#opening-demo",
    "href": "01-introduction.html#opening-demo",
    "title": "6¬† Stable Computing Environments",
    "section": "",
    "text": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Generate some example data\nx = np.random.rand(100)  # Generate 100 random numbers between 0 and 1\ny = 2 * x + 1 + np.random.randn(100)  # Apply a linear relationship with noise\n\n# Create the scatter plot\nplt.figure(figsize=(8, 6))  # Set the figure size\nplt.scatter(x, y)  # Create the scatter plot\n\n# Add labels and title\nplt.xlabel(\"X\")\nplt.ylabel(\"Y\")\nplt.title(\"Simulated Data\")\n\n# Show the plot\nplt.grid(True)  # Add a grid for better readability\nplt.savefig(\"plot.png\")\n\npython plot.py\n\n\n\ndocker run -v $(pwd):/app -w /app czentye/matplotlib-minimal python app.py\n\n\n\n\n\n\nNote\n\n\n\nThis demonstration consists of a Python script requiring two dependencies: numpy and matplotlib. If any of these dependencies are missing, the script will not run.\nBy running the script in a Docker container, the dependencies are provided and the script will run successfully and creates a file plot.png with a scatter plot.",
    "crumbs": [
      "Docker Fundamentals",
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Stable Computing Environments</span>"
    ]
  },
  {
    "objectID": "01-introduction.html#what-is-a-computing-environment",
    "href": "01-introduction.html#what-is-a-computing-environment",
    "title": "6¬† Stable Computing Environments",
    "section": "6.2 What is a computing environment?",
    "text": "6.2 What is a computing environment?\nThe computing environment is the set of software tools and libraries that are used to run a program. It includes the operating system, the programming language, and any other software that is required to run the program.\nResearch software typically consists of multiple dependencies, such as libraries, compilers, and other software tools.\nIn addition, software tools and libraries are constantly updated, which can lead to compatibility issues. For example, a program that was written to run on a specific version of a library may not work on a newer version of the library. Also, functionality may change between versions, or bugs may have been fixed or newly introduced.\nFor reproducibility it is thus important to record the computing environment in which the software was developed and tested.\nTools to record the computing environment include:\n\nconda\nPython venv\nR: renv, packrat\n\n\n\n\n\n\n\nNote\n\n\n\nHow are dependencies managed in Matlab?\n\n\nHowever, recording the computing environment is not enough. It is also important to be able to recreate the computing environment, including underlying system libraries.",
    "crumbs": [
      "Docker Fundamentals",
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Stable Computing Environments</span>"
    ]
  },
  {
    "objectID": "01-introduction.html#why-are-stable-computing-environments-important-for-reproducible-research",
    "href": "01-introduction.html#why-are-stable-computing-environments-important-for-reproducible-research",
    "title": "6¬† Stable Computing Environments",
    "section": "6.3 Why are stable computing environments important for reproducible research?",
    "text": "6.3 Why are stable computing environments important for reproducible research?\n\nReproducibility: A stable computing environment ensures that the software will run the same way every time it is executed. This is important for reproducibility, as it allows others to run the software and obtain the same results.\nPortability: A stable computing environment can be easily shared with others, allowing them to run the software on their own systems.\nCollaboration: A stable computing environment allows multiple researchers to work on the same project without worrying about compatibility issues.\nLongevity: A stable computing environment ensures that the software will continue to run in the future, even as software tools and libraries are updated.\n\n\n\n\n\n\n\nThe house analogy\n\n\n\n\n\nImagine your research project as your home that provides functionality for cooking, sleeping, working/studying, etc.\nWhen you install all software tools and libraries on your laptop, your kitchen, living room and bed are all in the same room. Everything is unseparable, and possibly interdependent: If you blow a fuse in the kitchen, the power in the whole rooms goes out.\nWith virtual environments, you can think of your research project as a house with separate rooms. Each room has its own purpose and is independent of the others. If you blow a fuse in the kitchen, the power in the living and bedroom is still on. However, if it rains through the roof, all rooms might be affected.\nWhen you containerize your software environments, each room is a shipping container. Each part can be shipped to another location, and still work as intended.\n\n\n\nHouse example",
    "crumbs": [
      "Docker Fundamentals",
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Stable Computing Environments</span>"
    ]
  },
  {
    "objectID": "01-introduction.html#use-cases",
    "href": "01-introduction.html#use-cases",
    "title": "6¬† Stable Computing Environments",
    "section": "6.4 Use cases",
    "text": "6.4 Use cases\n\nResolve Depdendencies and simplify Installation - Containers can be used to package software and its dependencies into a single unit that can be easily installed and run on any system. This is useful for software that has complex dependencies or requires specific versions of libraries.\nReproducibility: Containers can be used to create reproducible computing environments that can be easily shared with others. This is important for reproducible research, as it allows others to run the software and obtain the same results. For example, the initative BioContainers provides a collection of bioinformatics tools in containers.\nScalability: Containers can be easily scaled up to run on multiple machines, allowing for parallel processing of large datasets. This is important for high-performance computing applications, such as machine learning and data analysis.\nDevelopment: Containers can be used to create isolated development environments that are separate from the host system. This is useful for testing new software tools and libraries without affecting the host system.\nCloud computing: With the advent of cloud computing, containerization has become an important tool for deploying software in the cloud. Containers can be easily deployed on cloud platforms such as Amazon Web Services (AWS), Google Cloud Platform (GCP), and Microsoft Azure without worrying about the underlying operating system and installed libraries on the host system.",
    "crumbs": [
      "Docker Fundamentals",
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Stable Computing Environments</span>"
    ]
  },
  {
    "objectID": "03-first_steps.html",
    "href": "03-first_steps.html",
    "title": "8¬† First steps with Docker",
    "section": "",
    "text": "8.1 Install Docker\nSee Installation Instructions.",
    "crumbs": [
      "Docker Fundamentals",
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>First steps with Docker</span>"
    ]
  },
  {
    "objectID": "03-first_steps.html#the-docker-command-line-interface-cli",
    "href": "03-first_steps.html#the-docker-command-line-interface-cli",
    "title": "8¬† First steps with Docker",
    "section": "8.2 The Docker Command Line Interface (CLI)",
    "text": "8.2 The Docker Command Line Interface (CLI)\nAlthough Docker is now also provided with a graphical user interface, it is important to understand the command line interface (CLI) as it is the most powerful way to interact with Docker. Furthermote, if you work on a remote server such as a high performance computing cluster or a compute cloud, you will not have access to a graphical user interface.\nRun your first Docker command. It should show you the version of Docker that is installed on your machine.\ndocker --version\nTo check that Docker is able to run containers, you can run the following command:\ndocker container ls\nThis command lists a summary of all running containers. If you have not run any containers yet, the output will be a empty table.\n\n\n\n\n\n\nDo you get an error message?\n\n\n\n\n\nIf you get an error message similar to the following, the underlying Docker engine is not running:\nCannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?",
    "crumbs": [
      "Docker Fundamentals",
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>First steps with Docker</span>"
    ]
  },
  {
    "objectID": "03-first_steps.html#run-the-hello-world-container",
    "href": "03-first_steps.html#run-the-hello-world-container",
    "title": "8¬† First steps with Docker",
    "section": "8.3 Run the hello-world container",
    "text": "8.3 Run the hello-world container\nNow run your first container:\ndocker run hello-world\nDo you get an output similar to the following?\nIf so, congratulations! üéâ You have successfully run your first container.\nHello from Docker!\nThis message shows that your installation appears to be working correctly.\n\nTo generate this message, Docker took the following steps:\n 1. The Docker client contacted the Docker daemon.\n 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub.\n    (amd64)\n 3. The Docker daemon created a new container from that image which runs the\n    executable that produces the output you are currently reading.\n 4. The Docker daemon streamed that output to the Docker client, which sent it\n    to your terminal.\n\nTo try something more ambitious, you can run an Ubuntu container with:\n $ docker run -it ubuntu bash\n\nShare images, automate workflows, and more with a free Docker ID:\n https://hub.docker.com/\n\nFor more examples and ideas, visit:\n https://docs.docker.com/get-started/\nLet‚Äôs break down what happened when you ran the hello-world container:\n\nThe Docker client contacted the Docker daemon.\nThe Docker daemon pulled the hello-world image from the Docker Hub.\nThe Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading.\nThe Docker daemon streamed that output to the Docker client, which sent it to your terminal.",
    "crumbs": [
      "Docker Fundamentals",
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>First steps with Docker</span>"
    ]
  },
  {
    "objectID": "03-first_steps.html#the-docker-run-command",
    "href": "03-first_steps.html#the-docker-run-command",
    "title": "8¬† First steps with Docker",
    "section": "8.4 The Docker run command",
    "text": "8.4 The Docker run command\nThe docker run command is the most important command in Docker. It creates a new container from an image and runs a command inside that container.\n\nStarts a Running Container - Starts a running container, based on the container image. Think of this as the ‚Äúalive‚Äù or ‚Äúinflated‚Äù version of the container ‚Äì it‚Äôs actually doing something.\nPerforms Default Action - If the container has a default action set, it will perform that default action. This could be as simple as printing a message (as above) or running a whole analysis pipeline!\nShuts Down the Container - Once the default action is complete, the container stops running (or exits). The container image is still there, but nothing is actively running.",
    "crumbs": [
      "Docker Fundamentals",
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>First steps with Docker</span>"
    ]
  },
  {
    "objectID": "03-first_steps.html#understand-the-docker-cli",
    "href": "03-first_steps.html#understand-the-docker-cli",
    "title": "8¬† First steps with Docker",
    "section": "8.5 Understand the Docker CLI",
    "text": "8.5 Understand the Docker CLI\nThe Docker command line interface consists of multiple levels. That means that you can run docker commands with different subcommands.\nInvoking a Docker command always starts with docker followed by a command and a subcommand such as docker [command] [subcommand] [additional options].\n\n\n\n\n\n\nExercise: Explore the Docker CLI\n\n\n\nRun docker to get an overview of the available commands. Explore some commands and subcommands. Which ones might be important for the rest of the workshop?\n\n\n\n\n\n\n\n\nGetting help with the Docker CLI\n\n\n\n\n\nFor every command you can add --help to get more information about the command and its options. For example, to get help on the run command, you can run:\ndocker run --help",
    "crumbs": [
      "Docker Fundamentals",
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>First steps with Docker</span>"
    ]
  },
  {
    "objectID": "03-first_steps.html#run-a-command-inside-a-container",
    "href": "03-first_steps.html#run-a-command-inside-a-container",
    "title": "8¬† First steps with Docker",
    "section": "8.6 Run a command inside a container",
    "text": "8.6 Run a command inside a container\nNow that you have run your first container, let‚Äôs do something that is a bit more useful.\nLet‚Äôs imagine for data science project, you want to use Python. Do you have Python installed on your machine? If not, you can run a Python container to run Python code.\ndocker run -it python:3.13-slim python\nYou should see a output similar to the following and are presented with a Python prompt:\n\nUnable to find image 'python:3.12-slim' locally\n3.12-slim: Pulling from library/python\n13808c22b207: Pull complete \n6c9a484475c1: Pull complete \n78bef5c7424f: Pull complete \n42f0d54f5caa: Pull complete \n1723cff2f16b: Pull complete \nDigest: sha256:541d45d3d675fb8197f534525a671e2f8d66c882b89491f9dda271f4f94dcd06\nStatus: Downloaded newer image for python:3.12-slim\nPython 3.12.3 (main, Apr 10 2024, 03:39:08) [GCC 12.2.0] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt;\nType print(\"Hello World\") or some calculation like 1+1 to interact with the Python interpreter.\nOf course, you can also run any other (more advanced) Python code üôÇ\nTo exit the Python interpreter, type exit(). This will also exit the container.",
    "crumbs": [
      "Docker Fundamentals",
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>First steps with Docker</span>"
    ]
  },
  {
    "objectID": "03-first_steps.html#managing-images-and-containers",
    "href": "03-first_steps.html#managing-images-and-containers",
    "title": "8¬† First steps with Docker",
    "section": "8.7 Managing images and containers",
    "text": "8.7 Managing images and containers\n\n8.7.1 Containers\nTo manage containers, you can use the docker container ls command. This command lists all running containers. If you want to see all containers, including stopped containers, you can add the -a (--all) option:\ndocker container ls -a\nYou see a output similar to this:\nCONTAINER ID   IMAGE         COMMAND    CREATED          STATUS                      PORTS     NAMES\n882a85072ff8   hello-world   \"/hello\"   11 minutes ago   Exited (0) 11 minutes ago             practical_jennings\nThis gives you an overview of all containers that are currently running or have been run on your computer. Take a moment to familarize yourself with the displayed information:\n\nCONTAINER ID column shows the unique identifier of the container\nIMAGE column shows the name of the image\nCOMMAND column shows the command that was run inside the container\nCREATED column shows when the container was created\nSTATUS column shows the current status of the container\nPORTS column shows the ports that are exposed by the container\nNAMES column shows the name of the container\n\n\n\n8.7.2 Images\nWhen you run a container, the underlying image is downloaded and stored on your computer. You can see all images that are stored on your computer with the following command:\ndocker image ls\nYou see a output similar to this:\nREPOSITORY    TAG       IMAGE ID       CREATED         SIZE\nhello-world   latest    d2c94e258dcb   11 months ago   13.3kB\nThis gives you an overview of all images that are stored on your computer. Take a moment to familarize yourself with the displayed information:\n\nREPOSITORY column shows the name of the image\nTAG column shows the version of the image,\nIMAGE ID column shows the unique identifier of the image\nCREATED column shows when the image was created\nSIZE column shows the size of the image.\n\nThe hello-world image is very small. However some images can be considerable larger. Therfore, it makes sense to monitor the size of your images and remove images that you no longer need.\n\n\n\n\n\n\nExercise: Remove images\n\n\n\nRemove the hello-world image from your computer. Type docker image rm command, followed by the image id to remove an image. After removing, run docker image ls to check if the image has been removed.\n\n\n\n\n\n\n\n\nLayered file system\n\n\n\nNote that the image size does not necessarily translate to occupied disk space. Images that contain the same software components can share them and save disk space. The concept behind this is called layered file system. We will learn more about this later.",
    "crumbs": [
      "Docker Fundamentals",
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>First steps with Docker</span>"
    ]
  },
  {
    "objectID": "03-first_steps.html#finding-containers",
    "href": "03-first_steps.html#finding-containers",
    "title": "8¬† First steps with Docker",
    "section": "8.8 Finding containers",
    "text": "8.8 Finding containers\nFor most applications, Docker images are available and can be downloaded. Databases that host Docker images are called registries. Docker‚Äôs offical registry is Docker Hub. The docker run command is integrated with Docker Hub. For example, when we ran docker run hello-world, Docker automatically pulled the hello-world image from Docker Hub.\nWhen searching for public images, pay attention to the folllowing points:\n\nUse the official images when possible. They are maintained by the software developers and are usually well-documented. Regularly updated and popular containers are more likely to be secure and stable.\nIf the image is not offical, is it maintained by a well-established company or organisation?\nCheck if the image has a Dockerfile or Github repository associated it. Only then, you can reproduce how the image was produced and that it is not introducing potentially malicious code.\n\n\n\n\n\n\n\nExercise: Browse Docker Hub and run a container of yoru search\n\n\n\nGo to Docker Hub and search for a container that you would like to run. Run the container on your computer.\nNot sure, where to start? How about a container for a programming language (e.g.¬†R, Python, Matlab)?\nWant to go further? There‚Äôs a way to look for for container with a docker command. Do you find it?\n\n\n\n\n\n\n\n\nAlways specify the image‚Äôs version\n\n\n\nNote that images can have different versions that is specified in via the tag (e.g.¬†python:3.12). When the tag is not specified, Docker will use the latest tag by default that refers to the most recent version of the image. If the image is updated, the latest tag will point to the updated version. Therefore it is best practice to always specify the version of the image that you want to use.",
    "crumbs": [
      "Docker Fundamentals",
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>First steps with Docker</span>"
    ]
  },
  {
    "objectID": "04-dockerfile.html",
    "href": "04-dockerfile.html",
    "title": "9¬† Creating a Dockerfile",
    "section": "",
    "text": "9.1 Introduction\nResearch projects typically require a lot of specific software that is not available in predefined Docker image. In this session, we will create a first own Dockerfile to build a custom image.\nDo you remember the Docker workflow?\nIn order to build an image, we need to create a Dockerfile.",
    "crumbs": [
      "Docker Fundamentals",
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Creating a Dockerfile</span>"
    ]
  },
  {
    "objectID": "04-dockerfile.html#introduction",
    "href": "04-dockerfile.html#introduction",
    "title": "9¬† Creating a Dockerfile",
    "section": "",
    "text": "Docker workflow",
    "crumbs": [
      "Docker Fundamentals",
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Creating a Dockerfile</span>"
    ]
  },
  {
    "objectID": "04-dockerfile.html#what-is-a-dockerfile",
    "href": "04-dockerfile.html#what-is-a-dockerfile",
    "title": "9¬† Creating a Dockerfile",
    "section": "9.2 What is a Dockerfile?",
    "text": "9.2 What is a Dockerfile?\nA Dockerfile is a text document that contains all the commands a user could call on the command line to assemble an image.\nThe Dockerfile a set of simple commands that describe how to build a Docker image.\nLet‚Äôs have a look at this example for our own ‚ÄúHello World‚Äù application:\n# use the minimal linux alpine image\nFROM alpine:3.12\n\nENTRYPOINT [\"echo\", \"Hello World\"]\nThis Dockerfile uses only two commands:\n\nFROM specifies the base image to use.\nENTRYPOINT specifies the command to run when the container starts.\n\nTo build an image from this Dockerfile, save it into a new directory and run the following command:\ndocker build -t my-hello-world:0.1 .\nThe -t flag is used to tag the image with a name. The . at the end of the command specifies the build context, which is the directory where the Dockerfile is located.\nAfter the build is complete, you can run the image with the following command:\ndocker run my-hello-world\nDoes the output says ‚ÄúHello World‚Äù?\n\n\n\n\n\n\nTip\n\n\n\nNote how the command echo \"Hello World\" is specified as an list or array. This is the so called exec form of the ENTRYPOINT command. It is recommended because it explicitly states the command and its arguments.\nThere is also a shell form of the ENTRYPOINT command, which is specified as a string. Docker translates this internally to the exec form by running the command as shell command.",
    "crumbs": [
      "Docker Fundamentals",
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Creating a Dockerfile</span>"
    ]
  },
  {
    "objectID": "04-dockerfile.html#building-a-container-for-python-analysis",
    "href": "04-dockerfile.html#building-a-container-for-python-analysis",
    "title": "9¬† Creating a Dockerfile",
    "section": "9.3 Building a container for Python analysis",
    "text": "9.3 Building a container for Python analysis\nNext, we will create a Dockerfile that plots some data using Python. For this we require some more libraries, the Python script and the data to be plotted.\nThis image also builds upon the alpine image and then installs Python3 and the required libraries.\nFor the ENTRYPOINT, we will start the container with the Python script plot.py that reads the data from a CSV file.\n# Dockerfile\nFROM alpine\n\nRUN apk add --update python3 py3-pip py3-matplotlib py3-numpy py3-pandas\n\nENTRYPOINT [\"python3\", \"plot.py\"]\nWhat happens when you build this image and run the container?\nProbably you will get an error message that the file plot.py is not found.\npython3: can't open file '//plot.py': [Errno 2] No such file or directory\nWhy is that? Isn‚Äôt the file in the same directory as the Dockerfile?\nThe problem is that the a Docker container does not have access to the host file system. Neither, did we include the file in the image.\nLet‚Äôs do that now:\n# Dockerfile\nFROM alpine\n\nRUN apk add --update python3 py3-pip py3-matplotlib py3-numpy py3-pandas\n\nWORKDIR /app\n\nCOPY annual-temp-anomalies.csv plot.py /app\n\nENTRYPOINT [\"python3\", \"plot.py\"]\nLet‚Äôs look at the two new commands:\n\nWORKDIR sets the working directory for all subsequent commands. This is similar to the cd command in a shell.\nCOPY copies files from the host to the image. The first argument is the source file on the host, the second argument is the destination in the image.\n\nNow, build the image and run the container.",
    "crumbs": [
      "Docker Fundamentals",
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Creating a Dockerfile</span>"
    ]
  },
  {
    "objectID": "04-dockerfile.html#binding-host-directories-to-a-container",
    "href": "04-dockerfile.html#binding-host-directories-to-a-container",
    "title": "9¬† Creating a Dockerfile",
    "section": "9.4 Binding host directories to a container",
    "text": "9.4 Binding host directories to a container\nThe COPY command is useful to include files in the image, but it is not practical for large files or files that change frequently.\nTo access files on the host system from a container, we can use bind mounts. This is a way to mount a host directory into a container.\nTo bind mount the current directory into the container, we can use the -v flag when running the container:\ndocker run -v $(pwd):/app python-plot:0.1 \nThis command mounts the current directory into the /app directory in the container. The $(pwd) command is used to get the current directory.\n\n\n\n\n\n\nExercise:\n\n\n\nRun the container, not including the files in the image, but using a bind mount.",
    "crumbs": [
      "Docker Fundamentals",
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Creating a Dockerfile</span>"
    ]
  },
  {
    "objectID": "04-dockerfile.html#understand-layers",
    "href": "04-dockerfile.html#understand-layers",
    "title": "9¬† Creating a Dockerfile",
    "section": "9.5 Understand layers",
    "text": "9.5 Understand layers\nWhen building an image, Docker uses a layered file system. Each command in the Dockerfile creates a new layer in the image.\nWhen you build an image, Docker caches the layers. If you change a command in the Dockerfile, Docker will only rebuild the layers that are affected by the change.",
    "crumbs": [
      "Docker Fundamentals",
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Creating a Dockerfile</span>"
    ]
  },
  {
    "objectID": "04-dockerfile.html#publishing-an-image",
    "href": "04-dockerfile.html#publishing-an-image",
    "title": "9¬† Creating a Dockerfile",
    "section": "9.6 Publishing an image",
    "text": "9.6 Publishing an image\n\n9.6.1 Docker Hub\n\n\n9.6.2 Helmholtz Codebase Registry",
    "crumbs": [
      "Docker Fundamentals",
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Creating a Dockerfile</span>"
    ]
  },
  {
    "objectID": "05-advanced_docker.html",
    "href": "05-advanced_docker.html",
    "title": "10¬† Advanced docker",
    "section": "",
    "text": "10.1 Multi-container application (docker-compose)",
    "crumbs": [
      "Docker Fundamentals",
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Advanced docker</span>"
    ]
  },
  {
    "objectID": "05-advanced_docker.html#scaling",
    "href": "05-advanced_docker.html#scaling",
    "title": "10¬† Advanced docker",
    "section": "10.2 Scaling",
    "text": "10.2 Scaling\n\n10.2.1 Docker Swarm\n\n\n10.2.2 Kubernetes",
    "crumbs": [
      "Docker Fundamentals",
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Advanced docker</span>"
    ]
  },
  {
    "objectID": "05-advanced_docker.html#alternative-container-engine",
    "href": "05-advanced_docker.html#alternative-container-engine",
    "title": "10¬† Advanced docker",
    "section": "10.3 Alternative container engine",
    "text": "10.3 Alternative container engine\n\n10.3.1 Apptainer / Singularity",
    "crumbs": [
      "Docker Fundamentals",
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Advanced docker</span>"
    ]
  },
  {
    "objectID": "06-code_clinic.html",
    "href": "06-code_clinic.html",
    "title": "11¬† Code clinic",
    "section": "",
    "text": "11.1 Practical tips",
    "crumbs": [
      "Docker Fundamentals",
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>Code clinic</span>"
    ]
  },
  {
    "objectID": "06-code_clinic.html#practical-tips",
    "href": "06-code_clinic.html#practical-tips",
    "title": "11¬† Code clinic",
    "section": "",
    "text": "11.1.1 Mounting volumes",
    "crumbs": [
      "Docker Fundamentals",
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>Code clinic</span>"
    ]
  }
]